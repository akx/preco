import json
import re
from pathlib import Path

from identify.extensions import EXTENSIONS, NAMES
import subprocess
import io

IDENTIFY_LICENSE_URL = "https://raw.githubusercontent.com/pre-commit/identify/main/LICENSE"

PRELUDE = """
/// This file is automatically generated; please do not modify by hand.
/// Based on code from `identify` (https://github.com/pre-commit/identify)
/// `identify` is licensed:
///
/// {license}
///
use phf::phf_map;
"""

PSEUDO_TYPES = {'directory', 'symlink', 'socket', 'file', 'executable', 'non_executable', 'text', 'binary'}


def get_content_text(url):
    return subprocess.check_output(["curl", "-fsSL", url], encoding="utf-8")


def snake_case_to_pascal_case(s: str) -> str:
    return "".join(word.capitalize() for word in s.split("_"))


class TypeMap(dict):
    def add(self, identifier: str):
        rust_id = identifier.replace("#", "_sharp").replace("-", "_").replace("++", "_plus_plus")
        rust_id = re.sub("rc$", "_rc", rust_id)
        rust_id = snake_case_to_pascal_case(rust_id)
        self[identifier] = rust_id

    def get_rust_id(self, identifier: str) -> str:
        return f"Type::{self[identifier]}"


def build_type_map() -> TypeMap:
    type_map = TypeMap()
    for type in PSEUDO_TYPES:
        type_map.add(type)
    for map in (EXTENSIONS, NAMES):
        for _key, types in map.items():
            for type in types:
                type_map.add(type)
    return type_map


def main():
    license_text = get_content_text(IDENTIFY_LICENSE_URL)
    license_comment = "\n///   ".join(("\n" + license_text.strip()).splitlines())

    sio = io.StringIO()
    sio.write(PRELUDE.format(license=license_comment))

    type_map = build_type_map()

    sio.write("#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n")
    sio.write(f"pub enum Type {{\n")
    for types in sorted(type_map.values()):
        sio.write(f"    {types},\n")
    sio.write("}\n")

    sio.write("impl std::str::FromStr for Type {\n")
    sio.write("    type Err = ();\n")
    sio.write("    fn from_str(s: &str) -> Result<Type, ()> {\n")
    sio.write("        match s {\n")
    for str_type, rust_type in sorted(type_map.items()):
        sio.write(f"{json.dumps(str_type)} => Ok(Type::{rust_type}),\n")
    sio.write("_ => Err(()),\n")
    sio.write("}}}\n")

    for name, map in [
        ("extension", EXTENSIONS),
        ("name", NAMES),
    ]:
        max_val_length = max(len(v) for v in map.values())
        var_name = f"{name.upper()}_MAP"
        rtype = f"[Option<Type>; {max_val_length}]"
        sio.write(
            f"\nstatic {var_name}: phf::Map<&'static str, &'static {rtype}> = phf_map! {{\n"
        )
        for key, types in sorted(map.items()):
            padded_v = sorted(f"Some({type_map.get_rust_id(t)})" for t in types)
            padded_v += ["None"] * (max_val_length - len(padded_v))
            padded_v_str = ", ".join(padded_v)
            sio.write(f"    {json.dumps(key)} => &[{padded_v_str}],\n")
        sio.write("};\n")
        sio.write(f"pub fn map_{name}(name: &str) -> Option<&{rtype}> {{\n")
        sio.write(f"    {var_name}.get(name).cloned()\n")
        sio.write("}\n")

    Path("src/mappings.rs").write_text(sio.getvalue())


if __name__ == '__main__':
    main()
